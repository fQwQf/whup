# 数组想法

我们都知道，数组本质上是一块连续的内存，对于数组某个元素的访问，本质上就是访问数组首元素偏移下标乘以元素大小后的地址。但是，我们也应该明白，内存访问是线性的，因此，多维数组应该转化为一维数组。实际上，在低级语言（比如说汇编和HUST）中是存在数组的，但是只有一维数组——其实就是内存偏移。  

对于数组，如果要在HUST中访问，只需要简单采取这样的语法：
`array>->index`
可以把这个放在arg1,arg2或者result。不必担心：HUST会自动处理。  
其中，array是已登记的数组名，index是已登记的变量。数字也不必担心：expression会自动登记数字为变量。

下面着重说一下多维数组：

对于一个数组：  
number array[10][20][30]；

你应该把它转化为一个长度为10*20*30的一位数组，传给whupvm。  

当你要访问array[i][j][k]时，应该把i*20*30+j*30+k作为index传给whupvm。也就是说：

`array>->t1`

t1是储存i*20*30+j*30+k的临时变量。  

比如说：

```
number array[10][20][30];
array[i][j][k] = 4;
```

那么现在假设t114是计算i*20*30+j*30+k的临时变量（这是调用expression实现的），那么：  

| op | arg1 | arg2 | result |
|---|---|---|---|
| = | 4 |  | array>->t114 |

只要计算t114的代码在whupvm中成功执行，那么就没问题了。

除此之外，我还要定义一个size操作，用于统计变量或数组占用的内存大小：

| op | arg1 | arg2 | result |
|---|---|---|---|
| size | arg1 |  | result |

arg1是要查找的变量或数组名。result是数字变量。会把arg1占用的内存大小赋值给result。
