# 数组想法

## 数组后端想法
我们都知道，数组本质上是一块连续的内存，对于数组某个元素的访问，本质上就是访问数组首元素偏移下标乘以元素大小后的地址。但是，我们也应该明白，内存访问是线性的，因此，多维数组应该转化为一维数组。实际上，在低级语言（比如说汇编和HUST）中是存在数组的，但是只有一维数组——其实就是内存偏移。  

对于数组，如果要在HUST中访问，只需要简单采取这样的语法：
`array>->index`
可以把这个放在arg1,arg2或者result。不必担心：HUST会自动处理。  
其中，array是已登记的数组名，index是已登记的变量。数字也不必担心：expression会自动登记数字为变量。

下面着重说一下多维数组：

对于一个数组：  
`number array[10][20][30]；`

应该把它转化为一个长度为10*20*30的一位数组，传给whupvm。  

当要访问`array[i][j][k]`时，应该把`i*20*30+j*30+k`作为index传给whupvm。也就是说：

`array>->t1`

t1是储存`i*20*30+j*30+k`的临时变量。  

比如说：

```javascript
number array[10][20][30];
array[i][j][k] = 4;
```

那么现在假设t114是计算i*20*30+j*30+k的临时变量（这是调用expression实现的），那么：  

| op | arg1 | arg2 | result |
|---|---|---|---|
| = | 4 |  | array>->t114 |

只要计算t114的代码在whupvm中成功执行，那么就没问题了。

除此之外，我还要定义一个size操作，用于统计变量或数组占用的内存大小：

| op | arg1 | arg2 | result |
|---|---|---|---|
| size | arg1 |  | result |

arg1是要查找的变量或数组名。result是数字变量。会把arg1占用的内存大小赋值给result。
## 数组前端想法
数组声明时，应该把数组维度和每个维度的大小都传给whupvm，同时记录数组名。可以定义一个数组名表，记录数组名和数组维度的对应关系。  对于维度的判断，在声明时已经能够确定，可以在去除无关token后，利用token长度判断。    对于总长度的计算，应该采用递归的方式，从最内层开始计算，直到计算出数组大小。

数组访问时，应该把数组名和每个维度的下标都传给whupvm，同时记录下标。将每个下标乘以数组元素大小，得到偏移量。考虑到数组下标可能是变量或者表达式，因此此过程最好使用expression实现。对于变量或表达式下标，可以手动创建`( ) * + `token，然后和下标合并为tokens交给expression实现。

# 数组实现
## 数组声明
数组声明的语法是：
```javascript
type array[a][b][c]...;
```
其中，type是数组元素类型，分为number和string两种。a,b,c是数组每个维数的大小。
## 数组访问    
数组访问的语法是：
```javascript
array[index1][index2][index3]...;
```
其中，array是已声明的数组名，index是数组下标。index可以是数字，也可以是表达式。